// 어느 타 개발자의 parallelStream에 의한 장애 경험기를 적은 것입니다.
1. parrallelStream

java8에 추된 parallelStream은 멀티스레드 프로그래밍을 매우 쉽게 해준다.
개발자가 직접 스레드 혹은 스레드 풀을 생성하거나 관리할 필요없이 parallelStream(), parallel()만 사용하면,
알아서 'ForkJoinFramework'를 이용하여 작업들을 분할하고, 병렬적으로 처리하게 된다. 

이를 이용하면 매우 쉽게 병렬 프로그래밍을 사용할 수 있지만, 자칫하면 장애상황을 맞이 할수 있기때문에 조심해서 사용해야한다.

2. Tread Pool

parallelStream은 개발자 모르게 내부적으로 스레드 풀을 만들어서 작업을 병렬화시킨다. 여기서 중요한 점은 parallelStream 별로 스레드 풀을 만드는게 아니라는 점이다.
별도의 설정이 없다면 하나의 스레드 풀은 모든 parallelStream이 공유하게 된다.

3. Blocking IO

parallelSteam을 이용해 멀티 스레드를 이용하고, 그 코드 내부엔 db호출과 rest template을 이용한 동기 http 호출이 있다고한다면 어떻게 될까?

4. 장애 발생

API 응답이 상당히 느러지는 경우가 발생했다. 기준치를 넘어 알람이 오기 시작했고, 이슈를 확인해봤다. 
사실 잘 돌아가던 서비스고, 근래에 수정사항이 있었던 적도 아니어서 왜 발생했는지 추적하기가 꽤 힘들었다. 
이리 저리 추적하다가 쓰레드덤프를 생성하게됐고, 쓰레드 덤프를 생서해서 분석해보니 상당수의 쓰레드가 block혹은 wait 상태인걸 발견했다.

5. 장애 원인

리스트를 돌면서 순차적으로 http 호출을 해야한다고 생각해보자. 리스트의 크기가 5개라면 parallelStream을 이용해 5개의 스레드을 만들어 병렬로 호출하면 더 빨라질것 같다.
그리고 아마도 이런 의도로 코드 내부에 parallelStream을 쓴곳들이 있는 거스로 보인다. 하지만 정말 parallelStream 으로 동작했을때 더 빠른지,
그리고 일반 stream이 조금 더 느릴지라도 서비스 스펙을 위반할정도로 느린지는 테스트를 통해 확인해봐야한다. 일단 내가 맞은 준장애상태의 원인은 
parallelStream을 통해 io 작업을 하는 코드 때문이었다. parallelStream은 위에서 말한대로 스레드 풀을 공유한다!!