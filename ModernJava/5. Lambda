1. 람다가 뭔데요? 

지난 챕터에서는 동작 파라미터화를 통해서 파라미터로 메서드의 동작 자체를 전달해주는 것을 배웠다. 
이때, 메서드의 동작을 전달하기 위해서 별도의 @Override 어노테이션이나 상속된 메서드 이름 등, 동작 외에 다른 코드들이 반복되어 상당히 불편했다.
람다 표현식은 이를 해결하기 위해서, 단순히 '필요한 동작에 대한 행위만' 메서드로 전달할 수 있도록 익명 함수를 단순화한 것이다. 

람다 표현식은 다음고 같은 특징을 가진다.

1. 메서드에 이름이 없으니까 "익명"이다. (메서드에 대한 네이밍을 고만할 필요가 없다)
-> 이름은 없지만, 파라미터 리스트와 바디, 반환 형식, 발생 가능한 예외 리스트는 가질 수 있다.
2. 함수 : 특정 클래스에 종속되지 않고, 독립적으로 구성된다. 하지만 메서드처럼 파라미터, 바디, 리턴 값, 가능한 에외까지 모두 포함한다!
3. 전달 : 람다 표현식은 마치 '일급 객체 처럼' 인수로 전달하거나, 변수로 저장이 가능하다.
4. 간결성 : 코드가 간결해진다! 단순히 동작 자체만 넘겨줄 수 있다.

람다 표현식은 어떻게 구성되어 있을까?

(Crew a1, Crew a2) -> Integer.compare(a1.getAge() a2.getAge());

(Crew a1, Crew a2) : 람다 파라미터, 현재 코드에서는 compare에 사용되는 파라미터 2개를 의미한다.
-> : 화살표는 파라미터 리스트와 바디를 구분해주는 역할을 한다.
Integer.compare(a1.getAge(), a2.getAge()) : 람다 바디, 람다의 반환값을 표현해준다.

또한, 람다는 크게 표현식 스타일과 블록 스타일로 표현할 수 있다.
표현식 스타일 :  () -> "Hello World!"
블록 스타일 : () -> {return "Hello Crew!";}

블록에서는 return과 세미콜론을 붙여줘야 한다. 주로 여러 행을 입력해야 할 때 사용하며, 
로직이 간결한 경우 표현식 스타일로도 만들 수 있다. 


2. 그래서 람다.. 어디서 사용할까요?

람다로 간결해진다는 것까지는 알게 되었다. 하지만, 이를 어떻게 응용하면 좋을지 아직 감이 잡히지 않는다.
교재에서는 다음과 같이 람다의 사용법을 설명한다.

=> 주로 함수형 인터페이스에서 람다를 사용합니다.

갑자기 함수형 인터페이스? 무슨 말인지 이해하기 어려울 수 있지만, 우리는 이미 함수형 인터페이스를 본 적이 있다. 함수형 인터페이스는
'디폴드 메서드의 유무에 관계없이, 오직 추상 메서드를 1개만 가지는 인터페이스'이다.
아래는 자바에서 제공하는 대표적인 함수형 인터페이스 중 하나인 Predicate이다.

@FunctionalInterface
pulbic interface Predicate<T> {
    boolean test (T t);
}

우리는 챕터 2에서 사용하였던 다중 조건에 대해 검증을 위해 Predicate 인터페이스를 사용하였다.
여기서 Predicate<T>를 함수형 인터페이스라고 할 수 있으며, 오직 하나의 추상 메서드인 'test()'만 가지고 있다.

우리가 흔히 정렬할 때 사용하는 Comparator<T> 역시, 함수형 인터페이스의 일종이다.

@FunctionalInterface
public interface Comparator<T>{
    int compare(T o1, T o2);
}

compare()라는 추상 메서드를 가지고 있으며, 자바에서는 명시적으로 해당 인터페이스가 함수형 인터페이스임을 알리기 위해서
@FuntionalInterface라는 어노테이션을 붙여서 표현한다. 해당 애노테이션을 붙이면 해당 인터페이스가 함수형 인터페이스임을 보장하며,
추상 메서드가 없거나, 그 외 메서드가 추가되거나, 함수형 인터페이스의 정의에 맞지 않게 되면 컴파일 에러가 발생하게 된다. 


3. 추상 메서드는?

추상 메서드의 정의에 대해서 헷갈릴 수도 있다. 추상 메서드란, 자식 클래스에서 반드시 오버라이딩 해야지 
사용할 수 있는 메서드를 의미한다. 즉, Comparator를 구현한 클래스는 반드시 compare()를 구현해야한다.

NaturalOrderComparator implements Comparator<Comparable<Object>> {

    @Override
    public int compare(Comparable<Object> c1, Comparable<Object> c2) {

        return c1.compareTo(c2);
    }
}

Comparator를 기본으로 구현한 Comparator의 구현체인 NaturalOrderComparator를 가져왔다.
해당 클래스를 보면 위와 같이 compare를 구현한 것을 볼 수 있다.


// 원본블로그 : https://cl8d.tistory.com/m/36  