1. 동작 파라미터화

우리는 어떻게하면 변화하는 요구사항 속에서 유동적으로 대응할 수 있을까?
가장 먼저, 그냥 요구사항에 맞도록 가능한 모든 속성에 대해서 전부 시도하는 방법이 있다.

1) 백엔드 크루면서 25살 이하인 크루 모으기
2) 프론트엔드 크루면서 23살 이하인 크루 모으기
3) 안드로이드 크루면서... (etc)

이렇게 계속 케이스가 추가 된다면, 건건 마다 로직을 짜고 테스트케이스도 추가해야하는 번거로움이 발생한다.

그리하여 
=> 비슷한 코드가 반복해서 존재한다면, 해당 코드를 추상화 하자.

현재의 요구사항을 생각해보자. 

1) 백엔드 크루라면 통과, 아니라면 땡!
2) 25살 이하인 크루라면 통과, 아니라면 땡!

우리는 위 문장을 보고 무언가 중복되는 걸 찾을 수 있다. '~라면 통과, ~가 아니라면 땡!'
즉, 두 조건 모두 참과 거짓에 대해 반환을 하고 있다는 것을 알 수 있다. 바로 boolean이다.
그리고, 자바에는 참/거짓에 대응하기 위해, 꽤나 멋진 함수형 인터페이스를 제공하고 있다.

@FunctionalInterface
public interface Predicate<T>{
    boolean test(T t);
}

물론, 이 친구에 대해 지금은 몰라도 된다. 우리는 이 친구를 모방해서 'CrewPredicate'라는 함수형 인터페이스를 만들 것이다.
우리는 현재 '크루'에 대해서 '무슨무슨 조건으로 필터링!'을 하고 싶은 것이기 때문에, 크루를 인자로 받아서 필터링 조건은 내부 구현체에게 
맡기는 방향으로 설계를 진행할 것이다. 그럼, 다음과 같은 인터페이스를 생성할 수 있다.

public interface CrewPredicate {
    boolean test (Crew crew);
}

이 친구는 이제, 인자로 들어온 Crew에 대해서 판단하고, 구현 클래스를 통해서 선택조건에 대해 구체화를 진행할 것이다.
우리의 현재 조건인 '백엔트 크루'와 '25살 이하인 크루'를 뽑기 위해 다음과 같은 구현 클래스를 생성할 수 있다.

// 백엔드 크루를 뽑는 클래스.
public class BackendCrewPredicate implements CrewPredicate {
    public boolean test (Crew crew){
        return crew.getCourese.equals(BACKEND);
    }
}

// 25살 이하인 크루를 뽑는 클래스
public class AgeCrewPredicate implements CrewPredicate {
    public boolean test(Crew crew){
        return crew.getAge() <= 25;
    }
}

위 상황에 맞춰서 다양한 동작을 실행하고 있다. "상황에 따라 다른 동작을 실행해?" => 맞다, 전략패턴이다.
인터페이스를 통해서 우리는 '조건은 모르겠지만, 그냥 맞는지 아닌지에 대한 정보를 줄 거야!'라는 것만 선언해두고,
내부적인 로직은 구현체에게 위임하여 상황에 따라 백엔드 크루도 뽑고, 25살 이하인 크루도 뽑을 수 있도록 '갈아끼우는' 로직을 만들어낸 것이다.

우리는 이것을 조금 더 멋진 말로 표현할 수 있다.
=> 각각의 알고리즘을 '캡슐화' 하는 알고리즘 패밀리를 정의하고, 런타임에 알고리즘을 선택하게 만들자.

여기서 우리는 인터페이스를 통해 캡슐화를 진행했으며, CrewPredicate가 일종의 알고리즘 패밀리이다.
그리고 BackendCrewPredicate / AgeCrewPredicate가 일종의 전략이 된다.

우리는 이제, 이러한 전략을 동적으로 받아서 실행할 수 있도록 코드를 작성할 수 있다.

// 인자로 들어온 predicate의 구체 클래스에 대해서 필터 조건을 변경할 수 있다.
public List<Crew> filterCrews(List<Crew> crews, CrewPredicate p){
    List<Crew> resultCrews = new ArrayList<> ();
    for(Crew crew : crews){
        if(p.test(crew)){
            resultCrews.add(crew)
        }
    }
}

우리는 이제 '벡엔드 크루를 뽑는 것', '25살 이하인 크루를 뽑는 것' 같은 어떠한 '동작'자체를 파라미터로 전달해줄 수 있게 되었다.
이때, 파라미터로 인터페이스를 사용하여 해당 인터페이스의 구현체가 자유롭게 들어와서 전략을 선택할 수 있도록 만든 것이다.

하지만, 위 코드도 무언가 불편하다. 우리는 지금 포비의 요구사항만! 만족하는 구현 클래스를 만들었을 뿐이다.
네오의 요구사항인 '프론트엔트 크루'나 '23살 이상의 크루', '이름에 ㅈ이 들어가는 크루'등, 요구사항이 많아진다면
해당 요구사항 각각에 맞는 구현 클래스를 또 만들어줘야 한다는 것이다. 귀찮음이 많은 개발자는 이를 참을 수 없다.



2. 리팩터링 진행하기 - 익명클래스

어떻게 하면 이를 개선할 수 있을까? 구현 클래스를 만들지 않고 문제를 해결하는 방법은 없을까? 바로, 클래스의 선언과 인스턴스화를 동시에 
진행할 할 있는 '익명 클래스'를 활용하는 것이다. 익명 클래스는 '이름이 없는 클래스'이다. 클래스명에 대한 네이밍에 대해 고민할 필요도 없으며,
네이밍이 없기 때문에 외부에서 호출할수 없어 딱 1번만 사용하게 된다.


// 리팩터링 이전의 코드, 기존에는 이런 식으로 클래스를 선언해주었다.
List<Crew> backendCrews = filterCrews(crews, new BackendCrewPredicate());
List<Crew> ageCrews = filterCrews(crews, new AgeCrewPredicate());

// 익명 클래스를 활용해보자!
// CrewPredicate를 구현하는 객체를 만드는 것이다.
List<Crew> backendCrews = filterCrews(crews, new CrewPredicate(){

    @Override
    public boolean test(Crew crew){
        return crew.getCourse.equals(BACKEND);
    }
});

List<Crew> ageCrews = filterCrews(crews, new CrewPredicate(){

    @Override
    public boolean test(Crew crew){
        return crew.getAge() <= 25;
    }
});
// 원본블로그 : https://cl8d.tistory.com/m/36