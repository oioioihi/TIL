## 메모리 할당방식

- 메모리보다 더 큰 프로그램을 실행시키는 방법은 무엇이었일까? (메모리 = 1GB, lol = 9GB)

  - 게임을 메모리에 올릴 수 있도록 잘라서, 당장 실행 시켜야 할 부분만 메모리에 올린다.
  - 나머지는 용량이 큰 하드디스크의 스왑영역에 저장하는 기법이다. => Memory Overlay
  - 이렇게 하면 사용자는 메모리가 9GB인것 처럼 느낀다.
  - 하지만 실제 메모리가 9GB인 컴퓨터 보다는 느리게 동작한다.

  

  <img src="./capture/Screenshot 2024-03-06 at 23.05.44.png" alt="Screenshot 2024-03-06 at 23.05.44" style="zoom: 50%;" />

 그렇다면, 오늘날의 멀티 프로그래밍 환경에서는 메모리 관리를 어떻게 할까?



#### 1. 가변 분할 방식 (Segmentation)

---

- 프로세스가 크면 메모리도 크케 할당하는 방법.
- 한 프로세스가 메모리에 연속된 공간에 할당 되기 때문에 '연속 메모리 할당'이라고 한다.
- 장점 : 
  - 한 프로세스가 메모리에 연속된 공간에 할당되기 때문에, 프로세스 크기보다 큰 메모리가 할당되는 일이 없다. (프로세스의 크키게 딱 맞게 할당됨. 내부 단편화 X)
- 단점 : 외부 단편화가 발생할 수 있다.
  - Ex. 프로세스A(5MB)와 프로세스C(1MB)가 작업이 끝나고 해당 메모리 공간이 비어 있는 상황에서 새로운 프로세스B(6MB)가 메모리 할당이 필요한 상황에서, 연속된 메모리 6MB가 있지 않기 때문에 자원할당이 불가능하다. -> 외부 단편화
  - 조각모음 : 실행중인 프로세스를 잠시 멈추고, 빈 메모리 공간을 하나로 합치는 것 : 오버헤드가 발생



<img src="./capture/Screenshot 2024-03-06 at 23.12.29.png" alt="Screenshot 2024-03-06 at 23.12.29" style="zoom:49%;" />



#### 2. 고정 분할 방식(Paging)

---

- 프로세스 크기와 상관없이 똑같은 메모리를 할당하는 방법.
- 한 프로세스가 여러개로 쪼개져 메모리에 할당 되기 때문에 '비연속 메모리 할당'이라고 한다.
- 장점 :
  - 같은 크기로 메모리를 나누기 때문에 구현이 단순함
- 단점 :
  - 작은 프로세스도 큰 영역에 할당되어 할당되어, 공간이 낭비되는 내부단편화가 발생할 수 있다.



<img src="./capture/Screenshot 2024-03-06 at 23.11.12.png" alt="Screenshot 2024-03-06 at 23.11.12" style="zoom: 43%;" />



 #### 3. 버디 시스템

---

- 버디 시스템은 2의 승수로 메모리를 분해 메모리를 할당하는 방식이다.
- 장점 : 
  - 가변분할 방식처럼 프로세스 크기에 맞추어 할당되는 메모리 크기가 달라진다.
  - 외부 단편화를 방지하기 위해 메모리 공간을 확보하는 것이 간단하다.
  - 고정분할 방식처럼 내부 단편화가 발생하기는 하지만, 많은 공간의 낭비가 발생하지 않는다.
- 
- 상황 : 
  - 1. 메모리 크기가 2^11인 2048byte라고 가정한다.
    2. 크기가 500byte인 프로세스가 메모리 할당을 원한다.
    3. 2의 승수로 500byte보다 작은 값을 만날때 까지 공간을 나눈다.
    4. 3번을 나누면 256byte 공간이 나오는데, 여기엔 500byte 프로세스를 할당할 수 없다.
    5. 그럼 여기보다 큰 구역인 512byte공간에 프로세스를 할당한다.
    6. 내부단편화가 발생하지만 12byte 밖에 발생하지 않는다.
    7. 이 프로세스가 실행을 마치고 나가도 메모리를 합치기 쉽다. => 2의 승수로 동일하게 공간을 나누어놨기 때문이다. => 조각모음보다 간단하다.



<img src="./capture/Screenshot 2024-03-07 at 23.03.13.png" alt="Screenshot 2024-03-07 at 23.03.13" style="zoom: 33%;" />

