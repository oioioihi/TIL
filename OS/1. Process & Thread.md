## Program & Process

- Program : 하드디스크등과 같은 저장장치에 저장된 명령문의 집합체. (Ex. 카톡, 브라우저, 노션 등)
- Process : 실행중인 프로그램. 메모리를 할당 받은 실행 하고 있는 프로그램을 의미.



## Multi Programming = Memory 관정

- 멀티 프로그래밍 : 메모리에 여러 개의 프로세스가 올라온 것.
- 유니 프로그래밍 : 메모리에 단 하나의 프로세스만 올라가 있는 것.

<img src="./capture/Screenshot 2024-02-18 at 22.38.38.png" alt="Screenshot 2024-02-18 at 18.59.13" style="zoom: 33%;" />



## Multi Processing = CPU 관점

- 멀티 프로세싱 : CPU가 여러 개의 프로세스를 처리하는 것.





## PCB = Process Control Block

- PCB :  운영체제가 프로세스의 정보를 저장하는 연결 리스트
  - 포인터 : 부모와 자식 프로세스에 대한 포인터와 할당된 자원에 대한 포인터와 프로세스의 한 상태에서 다른 상태로 전환될 때 저장하는 포인터를 가지고 있음.
  - 프로세스 상태 : 현재 프로세스의 다섯가지 상태를 나타냄(생성, 준비, 실행, 대기, 완료)
  - 프로세스 ID : PID, 프로세스 식별자
  - 프로그램 카운터 : 시분할 시스템으로 진행 될때 , 중지 되었던 프로세스가 다음에 실행될 명령어의 주소를 포함하는 프로그램 카운터를 저장.
  - 레지스터 정보 : 프로그램 카운터와 마찬가지로 CPU를 뺏기고 다시 시작할 때 이전에 사용하던 값을 복구하기 위한 용도
  - 메모리 관련 정보 : 프로세스가 메모리에 있는 위치 정보, 메모리 침범을 막기위한 경계레지스터 값등이 저장.
  - CPU 스케줄링 정보 : CPU 스케줄링에 필요한 우선순위, 최종 실행시간, CPU 점유시간등이 저장.






## 프로세스 상태

: 오늘날의 운영체제는 동시에 수많은 프로세스가 실행된다. 운영체제가 수 많은 프로세스를 빠르게 돌아가면서 한번에 하나씩 처리하는데, 이를 시분할 시스템이라고 한다. 프로세스는 시분할 처리를 위한 다섯가지 상태를 가지고 있다.

	- 생성 (New) : PCB를 생성하고, 메모리에 프로세스를 적재를 요청한 상태. 메모리에 프로그램 적재를 승인 받으면 '준비' 단계로 넘어감.
	
	- 준비 (Ready) : CPU스케줄러에 의해 CPU할당을 기다리고 있는 상태. 대부분의 프로세스가 이 상태에 있다.
	
	- 실행 (Running) : 준비상태에 있는 프로세스가 CPU스케줄러에 의해 CPU를 할당받아 실행되는 상태. 실행상태에 있는 프로세스의 수는 CPU의 개수 만큼이다. 해당 프로세스에게 할당된 시간이 초과하면 다시 '준비' 상태로 넘어간다.
	
	- 대기 (Waiting) : 프로세스가 입출력 요청을하면, 입출력이 완료될 때 까지 기다리는 상태. 빠른 CPU에 비해 느린 I/O작업을 기다리는 동안 CPU자원이 낭비되기 때문에 대기상태로 넘기고 다른 프로세스를 수행 함.
	
	- 완료 (Terminated) : 프로세스가 종료된 상태. 프로세스가 사용했던 데이터를 메모리에서 제거하고, 생성된 PCB도 제거한다.





## Context Switching

: 프로세스를 실행하는 중에 다른 프로세서를 실해하기 위해, 실행중인 프로세스의 상태를 저장하고 다른 프로세스의 상태값으로 교체하는 작업이다. 컨택스트 스위칭이 일어날때 실행중인 프로세스의 PCB의 내용이 변경된다.

 => 실행 중이던 프로세스의 작업내용을 저장하고, 실행될 프로세스의 PCB내용으로 CPU가 다시 세팅된다.

	- PCB에서 변경되는 부분 : 프로세스 상태, 프로그램 카운터, 레지스터 정보, 메모리 관련 정보
 - 프로세스 A와 B가 컨텍스트 스위칭을 하는 상황
   - 1 : 프로세스 A가 실행하는데 CPU 점유시간을 초과함
   - 2 : 운영체제가 프로세스A가 CPU 사용시간을 초과했다고 판단하고, CPU에게 인터럽트를 발생시킨다.
   - 3 : 프로세스A가 하던일을 멈추고, 나중에 현재 상태에서 시작되어야 하기 때문에, 현재 CPU의 레지스터 값등을 PCB A에 저장한다.
   - 4 : 이제 PCB B를 참조해서 이전 프로세스 B의 상태로 CPU의 레지스터 값을 설정한다.
   - 5 : PCB B에는 다음 실행할 명령어의 주소를 가지고 있는 프로그램 카운터를 가지고 있기 때문에 , 바로 프로세스 B의 명령어를 실행할 수 있다.

- 컨택스트 스위칭이 발생하는 이유 : CPU 점유시간이 다 되거나, I/O요청이 있거나, 다른 종류의 인터럽트가 있을 때 발생한다. 



## 프로세스 생성과 종료

<img src="./capture/Screenshot 2024-02-18 at 22.37.18.png" alt="Screenshot 2024-02-18 at 22.37.18" style="zoom: 50%;" />

<img src="./capture/Screenshot 2024-02-18 at 22.15.56.png" alt="Screenshot 2024-02-18 at 22.15.56" style="zoom:33%;" />

1. '카카오톡'을 클릭하면 운영체제는 해당 프로그램의 코드영역과 데이터영역을 메모리에 로드하고, 빈 스택과 빈 힙을 만들어 공간을 확보한다.
2. 이제 이 프로세스를 관리하기 위한 PCB를 만들어서 값을 초기화 해준다.
3. 1-2번의 과정은 운영체제가 부팅되고 0번 프로세스가 생성될 때, 딱 한번만 실행된다.
4. 이후에 생기는 프로세스들은 새로 생성하지 않고, 0번 프로세스를 fork()해서 쓰게 됩니다. (더 빠르기 때문에)
5. 0번 프로세스를 복사해서 생성되는 프로세스는 자식 프로세스라고 하고, 이 자식 프로세스의 입장에서 0번 프로세스는 부모 프로세스가 됩니다.
6. 자식 프로세스는 부모 프로세스의 코드영역, 데이터영역, 스택영역과 PCB의 내용을 전부 복사합니다.
7. exec()함수를 실행시키면 부모를 복사한 자식 프로세스의 코드와 데이터영역을 원하는 값으로 덮어쓰게 됩니다.
8. 이때부터 자식 프로세스는 부모 프로세스와 완전 다르게 동작하게 된다.



~~~c#
// 1. 부모 프로세스
#include <studio.h>
#include <unistd.h>
  
  int main(){
  
    int pid;
    pid = fork( // pid = 1
    
    if(pid == 0) {// 자식 프로세스
      execlp("InternetBrowser","0",NULL);
      exit(0);
    }
  	else{	// 부모 프로세스
      // wait() 함수는 자식 프로세스에게서 exit() 신호가 올 때까지 기다리는 시스템 함수.
      // Context Switching을 거쳐 부모 프로세스에게 cpu가 할당되어도 자식 프로세스의 exit()신호가 오기 전까지는 다른 코드를 실행하지 않음.
      wait(NULL); 
      printf("InternetBrowser is closed");
      exit(0);
    }
}


// 2. 자식 프로세스
#include <studio.h>
#include <unistd.h>
  
  int main(){
  
    int pid;
    pid = fork() // pid = 0
    
    if(pid == 0) {// 자식 프로세스
      execlp("InternetBrowser","0",NULL);
      exit(0); // 자식 프로세스가 부모 프로세스에게 정상 종료를 알리고, 자기 프로세스를 종료함.
    }
  	else{	// 부모 프로세스
      wait(NULL);
      printf("InternetBrowser is closed");
      exit(0);
    }
}
~~~

- 만약 부모 프로세스가 자식 프로세스보다 먼저 종료되거나, 자식 프로세스가 비정상적으로 종료되 exit() 신호를 주지 못해서 Exit status를 읽지 못해 메모리에 계속 살아있는 상태를 '좀비 프로세스'라고 부른다.



## Thread

##### Thread가 생긴 이유

- 사용자가 운영체제에게 작업을 명령하면 그만큼 프로세스의 수가 늘어난다.
- 프로세스를 생성하면 PCB가 생성되고, 메모리에 코드, 데이터, 힙, 스택 영역을 만들어 줘야한다.
- 프로세스 10개 요청 = 10 * (PCB, code, data, stack, heap) => 즉, 너무 무거워진다.
- EX ) Chrome에 탭추가를 20개 하면, 20개의 프로세스가 생기고, 크롬이 메모리를 너무 많이 차지하는 문제가 생긴다.

##### Thread 란?

- 쓰레드는 프로세스 내에 존재하는 것으로 1개 이상 있을 수 있다.
- 한 프로세스 내의 쓰레드들은 그 프로세스의 PCB, 코드, 데이터, 힙 영역을 공휴한다.
- 스택은 공유하지 않고 각 쓰레드마다 가지고 있다.
- 쓰레드에게는 식별자가 부여되고, 쓰레드를 관리하기 한 Thread Control Block이 생성된다.
- EX. Chrome => 1개의 프로세스, 나머지는 쓰레드 / Firefox = 4개의 프로세스, 생성된 쓰레는 각 4개의 프로세스안에 존재

##### Process와 Thread의 장단점

- 안정성 : 프로세스 승
  - Process : 프로세스는 서로 독립적이기 때문에 하나의 프로세스가 문제가 있더라도 다른 프로세스가 영향을 받지 않는다.
  - Thread : 쓰레드는 하나의 프로세스 내에 존재하기 때문에, 해당 프로세스에 문제가 생기면, 그 안에 있는 모든 쓰레드에 문제가 생기게 된다. 
- 속도와 자원 : 
  - Process : 각각의 프로세스는 서로 고유한 자원인 PCB, Code, Data, Stack, Heap을 가지고 있어서 , 프로세스간의 통신을 하려면 IPC통신을 이용해야 하므로 오버헤드가 크고 속도가 느리다.
  - Thread : 쓰레드는 한 프로세스 내에서 스택영역을 제외한 영역은 모두 공유하기 때문에 오버헤드가 작고 쓰레드간의 통신은 데이터를 공유할 수 쉽지만 문제가 생길 수도 있다. 

<img src="./capture/Screenshot 2024-02-18 at 22.50.57.png" alt="Screenshot 2024-02-18 at 22.50.57" style="zoom: 50%;" />

